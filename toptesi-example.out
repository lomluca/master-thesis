\BOOKMARK [0][]{chapter*.1}{Acknowledgements}{}% 1
\BOOKMARK [0][]{chapter.1}{Introduction}{}% 2
\BOOKMARK [1][]{section.1.1}{The problem: Hadoop cluster autoscaling}{chapter.1}% 3
\BOOKMARK [1][]{section.1.2}{Apache Hadoop}{chapter.1}% 4
\BOOKMARK [2][]{subsection.1.2.1}{Hadoop HDFS}{section.1.2}% 5
\BOOKMARK [2][]{subsection.1.2.2}{Hadoop YARN}{section.1.2}% 6
\BOOKMARK [1][]{section.1.3}{Apache Spark}{chapter.1}% 7
\BOOKMARK [2][]{subsection.1.3.1}{Scheduling of stages and tasks}{section.1.3}% 8
\BOOKMARK [2][]{subsection.1.3.2}{Dynamic Resource Allocation}{section.1.3}% 9
\BOOKMARK [1][]{section.1.4}{Google Cloud Platform}{chapter.1}% 10
\BOOKMARK [2][]{subsection.1.4.1}{Cloud Storage Connector}{section.1.4}% 11
\BOOKMARK [1][]{section.1.5}{Elastic for YARN}{chapter.1}% 12
\BOOKMARK [0][]{chapter.2}{A piece in the puzzle: OBI}{}% 13
\BOOKMARK [1][]{section.2.1}{Architecture}{chapter.2}% 14
\BOOKMARK [2][]{subsection.2.1.1}{Heartbeat}{section.2.1}% 15
\BOOKMARK [2][]{subsection.2.1.2}{Scheduler}{section.2.1}% 16
\BOOKMARK [2][]{subsection.2.1.3}{Predictive module}{section.2.1}% 17
\BOOKMARK [2][]{subsection.2.1.4}{API}{section.2.1}% 18
\BOOKMARK [1][]{section.2.2}{Authentication and authorization}{chapter.2}% 19
\BOOKMARK [1][]{section.2.3}{Fault tolerance}{chapter.2}% 20
\BOOKMARK [2][]{subsection.2.3.1}{Deployment example on Kubernetes}{section.2.3}% 21
\BOOKMARK [0][]{chapter.3}{State of the art}{}% 22
\BOOKMARK [1][]{section.3.1}{Google Cloud Dataflow}{chapter.3}% 23
\BOOKMARK [2][]{subsection.3.1.1}{What we learned}{section.3.1}% 24
\BOOKMARK [1][]{section.3.2}{Shamash}{chapter.3}% 25
\BOOKMARK [2][]{subsection.3.2.1}{What we learned}{section.3.2}% 26
\BOOKMARK [1][]{section.3.3}{Spydra}{chapter.3}% 27
\BOOKMARK [2][]{subsection.3.3.1}{What we learned}{section.3.3}% 28
\BOOKMARK [1][]{section.3.4}{Cloud Dataproc Cluster Autoscaler}{chapter.3}% 29
\BOOKMARK [2][]{subsection.3.4.1}{What we learned}{section.3.4}% 30
\BOOKMARK [0][]{chapter.4}{Design}{}% 31
\BOOKMARK [1][]{section.4.1}{The core points}{chapter.4}% 32
\BOOKMARK [1][]{section.4.2}{The window logic for scaling up}{chapter.4}% 33
\BOOKMARK [1][]{section.4.3}{Selection of YARN metrics}{chapter.4}% 34
\BOOKMARK [1][]{section.4.4}{Downscaling}{chapter.4}% 35
\BOOKMARK [0][]{chapter.5}{Implementation}{}% 36
\BOOKMARK [1][]{section.5.1}{Go in a nutshell}{chapter.5}% 37
\BOOKMARK [1][]{section.5.2}{The autoscaler package}{chapter.5}% 38
\BOOKMARK [0][]{chapter.6}{Results}{}% 39
\BOOKMARK [1][]{section.6.1}{About the preemptible VMs}{chapter.6}% 40
\BOOKMARK [1][]{section.6.2}{Job analysis}{chapter.6}% 41
\BOOKMARK [1][]{section.6.3}{Test set I}{chapter.6}% 42
\BOOKMARK [2][]{subsection.6.3.1}{High scaling factor}{section.6.3}% 43
\BOOKMARK [2][]{subsection.6.3.2}{Medium scaling factor}{section.6.3}% 44
\BOOKMARK [2][]{subsection.6.3.3}{Low scaling factor}{section.6.3}% 45
\BOOKMARK [2][]{subsection.6.3.4}{Conclusions}{section.6.3}% 46
\BOOKMARK [1][]{section.6.4}{Test set II}{chapter.6}% 47
\BOOKMARK [2][]{subsection.6.4.1}{Fast decommissioning}{section.6.4}% 48
\BOOKMARK [2][]{subsection.6.4.2}{Slow decommissioning}{section.6.4}% 49
\BOOKMARK [2][]{subsection.6.4.3}{Conclusions}{section.6.4}% 50
\BOOKMARK [1][]{section.6.5}{Google autoscaler comparison}{chapter.6}% 51
\BOOKMARK [1][]{section.6.6}{Custom job}{chapter.6}% 52
\BOOKMARK [0][]{chapter.7}{Conclusion}{}% 53
\BOOKMARK [1][]{section.7.1}{Issues}{chapter.7}% 54
\BOOKMARK [1][]{section.7.2}{Improvements}{chapter.7}% 55
\BOOKMARK [2][]{subsection.7.2.1}{Node-oriented autoscaler}{section.7.2}% 56
\BOOKMARK [2][]{subsection.7.2.2}{Weights in the window metrics}{section.7.2}% 57
\BOOKMARK [0][]{chapter*.48}{References}{}% 58
